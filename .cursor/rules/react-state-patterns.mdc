---
description: React state management patterns - local state, props, and state synchronization
---

# React State Management Patterns

## Single Source of Truth Principle

### ❌ ANTI-PATTERN - Dual State (State Synchronization Hell)
```typescript
function MyComponent() {
  const { data: queryData } = useQuery('items');
  const [localData, setLocalData] = useState([]);
  
  // ❌ BAD: Syncing state in useEffect
  useEffect(() => {
    if (queryData) {
      setLocalData(queryData);  // Double state = bugs
    }
  }, [queryData]);
  
  return <List items={localData} />;
}
```

**Problems:**
- Race conditions (query updates before effect runs)
- Stale closures
- Unnecessary re-renders
- Hard to debug
- Progressive loading artifacts

### ✅ CORRECT - Single Source of Truth
```typescript
function MyComponent() {
  const { data } = useQuery('items');
  
  // ✅ GOOD: Use query data directly
  return <List items={data ?? []} />;
}
```

**OR** if you need local state only:
```typescript
function MyComponent() {
  const [items, setItems] = useState([]);
  
  const fetchItems = useCallback(async () => {
    const result = await fetch('/api/items');
    setItems(result.data);  // ✅ GOOD: Single state update
  }, []);
  
  useEffect(() => {
    fetchItems();
  }, [fetchItems]);
  
  return <List items={items} />;
}
```

---

## State Update Patterns

### 1. Direct State Updates (Controlled Components)

#### ❌ WRONG - Updating wrong state
```typescript
const [editingItem, setEditingItem] = useState(null);
const [formData, setFormData] = useState({});

// Dialog shows editingItem but updates formData!
<EditDialog
  item={editingItem}
  onChange={(field, value) => {
    setFormData(prev => ({ ...prev, [field]: value }));  // ❌ Wrong state!
  }}
/>
```

#### ✅ CORRECT - Update the state you're displaying
```typescript
const [editingItem, setEditingItem] = useState(null);

<EditDialog
  item={editingItem}
  onChange={(field, value) => {
    setEditingItem(prev => ({
      ...prev,
      [field]: value  // ✅ Update what you show
    }));
  }}
/>
```

### 2. Nested State Updates (Arrays/Objects)

#### Update object field
```typescript
setItem(prev => ({
  ...prev,
  name: newName
}));
```

#### Update array item
```typescript
setItems(prev =>
  prev.map(item =>
    item.id === targetId ? { ...item, quantity: newQty } : item
  )
);
```

#### Add to array
```typescript
setItems(prev => [...prev, newItem]);
```

#### Remove from array
```typescript
setItems(prev => prev.filter(item => item.id !== removeId));
```

---

## React Query vs Local State

### When to Use React Query
- **Server state** (data from API)
- **Shared data** (multiple components need it)
- **Cached data** (reduce API calls)
- **Background updates** (polling, refetch)

```typescript
// ✅ GOOD: Server state with React Query
const { data: lists, isLoading } = useQuery({
  queryKey: ['cutting-lists'],
  queryFn: fetchCuttingLists,
  staleTime: 5 * 60 * 1000,  // 5 minutes
});
```

### When to Use Local State
- **UI state** (modals, dropdowns, form inputs)
- **Temporary data** (not persisted)
- **Component-specific** (only this component needs it)

```typescript
// ✅ GOOD: UI state with useState
const [isOpen, setIsOpen] = useState(false);
const [searchQuery, setSearchQuery] = useState('');
```

### When to Use Both (Controlled Forms)
```typescript
function EditForm() {
  // Server data
  const { data: item } = useQuery(['item', id], () => fetchItem(id));
  
  // Local draft (user is editing)
  const [draft, setDraft] = useState(null);
  
  // Initialize draft when item loads
  useEffect(() => {
    if (item && !draft) {
      setDraft(item);  // ✅ OK: One-time initialization
    }
  }, [item, draft]);
  
  // Save mutation
  const { mutate } = useMutation(updateItem);
  
  const handleSave = () => {
    mutate(draft);  // ✅ Save draft to server
  };
  
  return (
    <form>
      <input
        value={draft?.name ?? ''}
        onChange={e => setDraft({ ...draft, name: e.target.value })}
      />
      <button onClick={handleSave}>Save</button>
    </form>
  );
}
```

---

## Dependency Arrays (useEffect, useCallback, useMemo)

### ✅ CORRECT - Empty array when deps are stable
```typescript
const fetchData = useCallback(async () => {
  setLoading(true);
  const result = await fetch('/api/data');
  setData(result.data);
  setLoading(false);
}, []);  // ✅ Empty: setState functions are stable in React

useEffect(() => {
  fetchData();
}, [fetchData]);  // ✅ fetchData never changes
```

### ✅ CORRECT - Include all external dependencies
```typescript
const fetchData = useCallback(async () => {
  const result = await fetch(`/api/data/${userId}`);
  setData(result.data);
}, [userId]);  // ✅ Refetch when userId changes

useEffect(() => {
  fetchData();
}, [fetchData]);
```

### ❌ WRONG - Missing dependencies
```typescript
const fetchData = useCallback(async () => {
  const result = await fetch(`/api/data/${userId}`);
  setData(result.data);
}, []);  // ❌ Missing userId - stale closure!
```

---

## Dialog State Management

### ✅ CORRECT Pattern
```typescript
function ParentComponent() {
  const [selectedItem, setSelectedItem] = useState(null);
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  
  const handleEdit = (item) => {
    setSelectedItem(item);      // Set item
    setIsDialogOpen(true);       // Open dialog
  };
  
  const handleSave = (updatedItem) => {
    // Save to backend
    await updateItem(updatedItem);
    
    // Update local state
    setItems(prev =>
      prev.map(i => i.id === updatedItem.id ? updatedItem : i)
    );
    
    // Close dialog
    setIsDialogOpen(false);
    setSelectedItem(null);
  };
  
  return (
    <>
      <List items={items} onEdit={handleEdit} />
      
      <EditDialog
        open={isDialogOpen}
        item={selectedItem}
        setItem={setSelectedItem}  // ✅ Allow direct updates
        onSave={handleSave}
        onClose={() => {
          setIsDialogOpen(false);
          setSelectedItem(null);
        }}
      />
    </>
  );
}

function EditDialog({ open, item, setItem, onSave, onClose }) {
  if (!item) return null;
  
  return (
    <Dialog open={open} onClose={onClose}>
      <input
        value={item.name}
        onChange={e => setItem({ ...item, name: e.target.value })}
      />
      <button onClick={() => onSave(item)}>Save</button>
    </Dialog>
  );
}
```

---

## Animation Delays and State

### ❌ WRONG - Animation delay masking as data loading
```typescript
<Stack spacing={2}>
  {items.map((item, index) => (
    <ScaleIn key={item.id} delay={index * 100}>
      <ItemCard item={item} />
    </ScaleIn>
  ))}
</Stack>
```

**Problem:** When `items` updates from API, cards appear progressively (0ms, 100ms, 200ms...), making it look like data is loading slowly!

### ✅ CORRECT - No delay or single entrance
```typescript
// Option 1: No animation delay
<Stack spacing={2}>
  {items.map((item, index) => (
    <ScaleIn key={item.id} delay={0}>
      <ItemCard item={item} />
    </ScaleIn>
  ))}
</Stack>

// Option 2: Single container animation
<ScaleIn>
  <Stack spacing={2}>
    {items.map(item => (
      <ItemCard key={item.id} item={item} />
    ))}
  </Stack>
</ScaleIn>

// Option 3: Stagger only on INITIAL mount
const [hasAnimated, setHasAnimated] = useState(false);

<Stack spacing={2}>
  {items.map((item, index) => (
    <ScaleIn
      key={item.id}
      delay={hasAnimated ? 0 : index * 50}
    >
      <ItemCard item={item} />
    </ScaleIn>
  ))}
</Stack>

useEffect(() => {
  if (items.length > 0) {
    setHasAnimated(true);
  }
}, [items]);
```

---

## Props vs State Decision Tree

```
Is the data from an API?
├─ Yes → Use React Query
└─ No → Is it shared between components?
    ├─ Yes → Lift state up or use Context
    └─ No → Is it persistent?
        ├─ Yes → localStorage + useState
        └─ No → useState only
```

---

## State Initialization Patterns

### 1. Simple Default
```typescript
const [count, setCount] = useState(0);
```

### 2. Lazy Initialization (Expensive Calculation)
```typescript
const [data, setData] = useState(() => {
  // Only runs once on mount
  return JSON.parse(localStorage.getItem('data')) ?? [];
});
```

### 3. From Props (Controlled → Uncontrolled)
```typescript
function Component({ initialValue }) {
  const [value, setValue] = useState(initialValue);
  
  // ⚠️ WARNING: initialValue changes won't update state!
  // Use key prop on parent to force remount if needed
}
```

### 4. Initialize from Server Data
```typescript
function Component() {
  const { data: serverData } = useQuery('items');
  const [draft, setDraft] = useState(null);
  
  // Initialize draft when serverData first loads
  useEffect(() => {
    if (serverData && !draft) {
      setDraft(serverData);
    }
  }, [serverData, draft]);
}
```

---

## Common Mistakes

### ❌ MISTAKE 1: Updating state based on previous props
```typescript
const [value, setValue] = useState(props.value);

useEffect(() => {
  setValue(props.value);  // ❌ Sync state with props
}, [props.value]);
```

**Fix:** Use controlled component pattern or key prop.

### ❌ MISTAKE 2: Not using functional updates
```typescript
setCount(count + 1);  // ❌ Stale closure in async code

// ✅ CORRECT
setCount(prev => prev + 1);
```

### ❌ MISTAKE 3: Direct mutation
```typescript
const [items, setItems] = useState([]);

items.push(newItem);  // ❌ Mutation!
setItems(items);      // ❌ React won't detect change

// ✅ CORRECT
setItems(prev => [...prev, newItem]);
```

---

## React 19 Patterns

### Use `use()` for Promises (React 19)
```typescript
import { use } from 'react';

function Component({ dataPromise }) {
  const data = use(dataPromise);  // ✅ Suspends until resolved
  return <div>{data.name}</div>;
}
```

### Actions (Form Actions)
```typescript
function Form() {
  const [isPending, startTransition] = useTransition();
  
  async function handleSubmit(formData: FormData) {
    startTransition(async () => {
      await updateData(formData);
    });
  }
  
  return (
    <form action={handleSubmit}>
      <input name="name" />
      <button disabled={isPending}>
        {isPending ? 'Saving...' : 'Save'}
      </button>
    </form>
  );
}
```

---

## Checklist

- [ ] Single source of truth for each piece of data
- [ ] No dual state syncing (query → local)
- [ ] Update the state you're displaying
- [ ] Use functional updates for state based on previous state
- [ ] Include all dependencies in useEffect/useCallback
- [ ] setState functions don't need to be in dependency arrays
- [ ] No animation delays masquerading as loading states
- [ ] Direct mutations are forbidden
- [ ] Controlled components update parent state
- [ ] Use React Query for server state

---

## References

- [CuttingListBuilder State Management](mdc:frontend/src/widgets/cutting-list-builder/CuttingListBuilder.tsx)
- [useCuttingListState Hook](mdc:frontend/src/widgets/cutting-list-builder/hooks/useCuttingListState.ts)
- [EditItemDialog Pattern](mdc:frontend/src/widgets/cutting-list-builder/dialogs/EditItemDialog.tsx)
