---
description: PostgreSQL + Prisma integration patterns, type safety, and best practices
---

# PostgreSQL + Prisma Patterns

## Type Safety with JSONB Fields

### ❌ WRONG - Direct null assignment
```typescript
await prisma.statistics.create({
  data: {
    activityData: null, // Type error with strict mode
    metadata: null
  }
});
```

### ✅ CORRECT - Use Prisma.DbNull for nullable JSON/JSONB
```typescript
import { Prisma } from '@prisma/client';

await prisma.statistics.create({
  data: {
    activityData: activityData ?? Prisma.DbNull,
    metadata: metadata ?? Prisma.DbNull
  }
});
```

**Why:** PostgreSQL JSON/JSONB columns need `Prisma.DbNull` for null values, not TypeScript `null`.

---

## Repository Pattern with Prisma

### Structure
```typescript
// repositories/CuttingListRepository.ts
import { PrismaClient, CuttingList as PrismaCuttingList } from '@prisma/client';

export class CuttingListRepository {
  constructor(private readonly prisma: PrismaClient) {}

  async findAll(): Promise<PrismaCuttingList[]> {
    return this.prisma.cuttingList.findMany({
      orderBy: { createdAt: 'desc' }
    });
  }

  async findById(id: string): Promise<PrismaCuttingList | null> {
    return this.prisma.cuttingList.findUnique({
      where: { id }
    });
  }

  async create(data: Omit<PrismaCuttingList, 'id' | 'createdAt' | 'updatedAt'>): Promise<PrismaCuttingList> {
    return this.prisma.cuttingList.create({ data });
  }

  async update(id: string, data: Partial<PrismaCuttingList>): Promise<PrismaCuttingList> {
    return this.prisma.cuttingList.update({
      where: { id },
      data
    });
  }

  async delete(id: string): Promise<void> {
    await this.prisma.cuttingList.delete({
      where: { id }
    });
  }
}
```

---

## Schema Design Best Practices

### Use JSONB for Complex Data
```prisma
model CuttingList {
  id          String   @id @default(cuid())
  name        String
  description String?
  status      String   @default("draft")
  sections    Json     @db.JsonB  // ✅ JSONB for performance
  weekNumber  Int?
  userId      String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([weekNumber])
  @@index([status])
}
```

**Best Practices:**
- Use `@db.JsonB` for PostgreSQL (faster than JSON)
- Add indexes on frequently queried fields
- Use `onDelete: Cascade` for automatic cleanup
- Use `cuid()` for IDs (better than UUID for sorting)

---

## Type Conversion Between Prisma and Domain

### Controller Layer - Type Mapping
```typescript
import { CuttingList as PrismaCuttingList, Prisma } from '@prisma/client';

// Domain type (what frontend expects)
interface CuttingList {
  id: string;
  name: string;
  weekNumber: number;  // Not nullable in domain
  sections: CuttingListSection[];  // Parsed from JSON
}

// Controller
export class CuttingListController {
  async getAllCuttingLists(req: Request, res: Response) {
    const lists = await cuttingListRepository.findAll();
    
    // Map Prisma type to Domain type
    const mapped: CuttingList[] = lists.map(list => ({
      id: list.id,
      name: list.name,
      weekNumber: (list.weekNumber ?? 0) as number,
      sections: (list.sections as unknown) as CuttingListSection[]
    }));
    
    res.json({ success: true, data: mapped });
  }
}
```

**Why casting is needed:**
- Prisma returns `Json` type for JSONB columns
- Frontend expects strongly-typed domain objects
- Use `unknown` intermediate cast for safety

---

## Query Performance Optimization

### 1. Enable Query Logging
```typescript
// src/index.ts
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient({
  log: [
    { emit: 'event', level: 'query' },
    { emit: 'event', level: 'error' },
    { emit: 'event', level: 'warn' },
  ],
});

prisma.$on('query', (e) => {
  if (e.duration > 100) {
    logger.warn('Slow query detected', {
      query: e.query,
      duration: `${e.duration}ms`,
      params: e.params,
    });
  }
});
```

### 2. Use Indexes
```prisma
model CuttingList {
  // ...
  
  @@index([userId, status])  // Composite index
  @@index([createdAt])       // Time-based queries
  @@unique([userId, weekNumber])  // Business constraint
}
```

### 3. PostgreSQL Performance Settings
```sql
-- Connection pooling
max_connections = 100
shared_buffers = 256MB
effective_cache_size = 1GB

-- Query performance
work_mem = 4MB
maintenance_work_mem = 64MB

-- Write performance
wal_buffers = 16MB
checkpoint_completion_target = 0.9
```

---

## Migration Best Practices

### Safe Migration Workflow
```bash
# 1. Generate migration (development)
npx prisma migrate dev --name add_cutting_list_week_number

# 2. Review generated SQL
cat prisma/migrations/*/migration.sql

# 3. Test migration on dev database
npm run db:migrate

# 4. Create backup before production deploy
npm run db:backup

# 5. Apply to production
npx prisma migrate deploy
```

### Data Migration Script Pattern
```typescript
// scripts/migrate-data.ts
import { PrismaClient } from '@prisma/client';
import * as fs from 'fs';

const prisma = new PrismaClient();

async function migrateJsonToPostgres() {
  const jsonData = JSON.parse(fs.readFileSync('./data/cutting-lists.json', 'utf-8'));
  
  for (const list of jsonData) {
    await prisma.cuttingList.create({
      data: {
        name: list.name,
        sections: list.sections,  // Prisma handles JSON conversion
        weekNumber: list.weekNumber,
        userId: 'default-user-id',
      },
    });
  }
  
  console.log(`Migrated ${jsonData.length} records`);
}

migrateJsonToPostgres()
  .catch(console.error)
  .finally(() => prisma.$disconnect());
```

---

## Error Handling with Prisma

### Known Error Codes
```typescript
import { Prisma } from '@prisma/client';

async function handlePrismaError(error: unknown) {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case 'P2002':
        // Unique constraint violation
        return { error: 'Record already exists' };
      case 'P2025':
        // Record not found
        return { error: 'Record not found' };
      case 'P2003':
        // Foreign key constraint failed
        return { error: 'Related record not found' };
      default:
        logger.error('Prisma error', { code: error.code, message: error.message });
        return { error: 'Database error' };
    }
  }
  throw error;
}
```

---

## Transactions

### Use Prisma Transactions for Multi-Step Operations
```typescript
async function updateCuttingListItem(
  listId: string,
  sectionId: string,
  itemId: string,
  itemData: WorkOrderItem
): Promise<void> {
  await prisma.$transaction(async (tx) => {
    // 1. Get current list
    const list = await tx.cuttingList.findUniqueOrThrow({
      where: { id: listId }
    });
    
    // 2. Update sections (JSONB)
    const sections = list.sections as any[];
    const updatedSections = sections.map(s => {
      if (s.id === sectionId) {
        return {
          ...s,
          items: s.items.map((i: any) => i.id === itemId ? itemData : i)
        };
      }
      return s;
    });
    
    // 3. Save back
    await tx.cuttingList.update({
      where: { id: listId },
      data: { sections: updatedSections }
    });
    
    // 4. Log activity
    await tx.activityLog.create({
      data: {
        action: 'UPDATE_ITEM',
        entityId: itemId,
        userId: 'current-user-id',
      }
    });
  });
}
```

---

## Health Checks

### Database Health Endpoint
```typescript
router.get('/health/database', async (req, res) => {
  try {
    // 1. Connection check
    await prisma.$queryRaw`SELECT 1`;
    
    // 2. Get stats
    const [stats] = await prisma.$queryRaw<any[]>`
      SELECT 
        COUNT(*) as total_connections,
        MAX(now() - query_start) as longest_query_duration
      FROM pg_stat_activity
      WHERE state = 'active'
    `;
    
    res.json({
      status: 'healthy',
      database: 'PostgreSQL 18.0',
      connections: stats.total_connections,
      longestQuery: stats.longest_query_duration,
    });
  } catch (error) {
    res.status(500).json({
      status: 'unhealthy',
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});
```

---

## Backup Strategy

### Automated Backup Script (PowerShell)
```powershell
# scripts/backup-postgres.ps1
$timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
$backupFile = "backup_$timestamp.sql"

docker exec lemnix-postgres pg_dump -U lemnix lemnix > $backupFile

if ($LASTEXITCODE -eq 0) {
    Write-Host "✅ Backup created: $backupFile"
} else {
    Write-Error "❌ Backup failed"
    exit 1
}
```

### npm script
```json
{
  "scripts": {
    "db:backup": "powershell -ExecutionPolicy Bypass -File scripts/backup-postgres.ps1"
  }
}
```

---

## TypeScript Language Server Cache Issues

### Problem: Prisma types not updating
If you see type errors after schema changes but Prisma client is regenerated:

```bash
# 1. Regenerate Prisma client
npx prisma generate

# 2. Restart TypeScript server in VS Code
Ctrl+Shift+P → "TypeScript: Restart TS Server"

# 3. Close/reopen file or restart Cursor
```

**Common scenario:** After adding fields to schema, old type errors persist even though runtime works.

**Solution:** This is a TypeScript LSP cache issue, not a code issue. Restart TS server.

---

## Checklist

- [ ] Use `Prisma.DbNull` for nullable JSON/JSONB fields
- [ ] Add indexes on frequently queried fields
- [ ] Use repository pattern for data access
- [ ] Map Prisma types to domain types in controllers
- [ ] Enable query logging for slow queries (>100ms)
- [ ] Use transactions for multi-step operations
- [ ] Handle Prisma error codes explicitly
- [ ] Create database health endpoint
- [ ] Set up automated backups
- [ ] Test migrations on dev before production

---

## References

- [Prisma Schema](mdc:backend/prisma/schema.prisma)
- [CuttingListRepository](mdc:backend/src/repositories/CuttingListRepository.ts)
- [Database Config](mdc:backend/src/config/database.ts)
