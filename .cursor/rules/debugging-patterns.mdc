---
description: Systematic debugging patterns - root cause analysis, logging, and troubleshooting
---

# Debugging Patterns ve Root Cause Analysis

## Sistematik Debugging Yakla≈üƒ±mƒ±

### 1. Problemi G√∂zlemle
- Semptomlarƒ± kaydet (ne oluyor?)
- Beklenen davranƒ±≈ü nedir?
- Ger√ßek davranƒ±≈ü nedir?
- Ne zaman ba≈üladƒ±?
- Tutarlƒ± mƒ± yoksa rastgele mi?

### 2. Hipotez Olu≈ütur
- Olasƒ± nedenler neler?
- En olasƒ± neden hangisi?
- Nasƒ±l test edilebilir?

### 3. Test Et ve Doƒürula
- Minimal test case olu≈ütur
- Deƒüi≈ükenleri izole et
- Log/debug ekle
- Sonu√ßlarƒ± g√∂zlemle

### 4. K√∂k Nedeni Bul
- Semptom ‚â† K√∂k Neden
- "5 Neden" tekniƒüini kullan
- Ger√ßek sorunu √ß√∂z, ge√ßici √ß√∂z√ºm deƒüil

---

## Case Study: Cutting List Progressive Loading

### üî¥ Sorun
Frontend'de kesim listeleri sƒ±rayla, belli aralƒ±klarla g√∂r√ºn√ºyor (100ms delay ile).

### ‚ùå Yanlƒ±≈ü Hipotezler (Semptomlar)
1. **"React Query cache sorunu"** ‚Üí Cache disable edildi, sorun devam etti
2. **"State sync problemi"** ‚Üí Dual state kaldƒ±rƒ±ldƒ±, sorun devam etti
3. **"Backend yava≈ü"** ‚Üí API 7 item'ƒ± anƒ±nda d√∂n√ºyor, sorun devam etti

### ‚úÖ K√∂k Neden Analizi

#### Adƒ±m 1: Backend'i Kontrol Et
```powershell
Invoke-RestMethod -Uri "http://localhost:3001/api/cutting-list" | ConvertTo-Json -Depth 3
```
**Sonu√ß:** API 7 item'ƒ± tek seferde d√∂n√ºyor. ‚úÖ Backend OK.

#### Adƒ±m 2: Frontend Data Flow'u ƒ∞zle
```typescript
console.log('[CuttingListBuilder] ‚úÖ Loaded:', result.data.length, 'lists');
```
**Sonu√ß:** Frontend 7 item'ƒ± tek seferde alƒ±yor. ‚úÖ Data flow OK.

#### Adƒ±m 3: Render Layer'ƒ± ƒ∞ncele
```typescript
// CuttingListsGrid.tsx
{cuttingLists.map((list, index) => (
  <ScaleIn delay={index * 100}>  // ‚ùå BINGO!
    <CuttingListCard ... />
  </ScaleIn>
))}
```

**K√∂k Neden:** Animation delay! 7 item aynƒ± anda render oluyor ama `ScaleIn` animation 100ms * index kadar geciktiriyor.

#### √á√∂z√ºm
```typescript
<ScaleIn delay={0}>  // ‚úÖ No delay
```

---

## Strategic Logging Pattern

### ‚ùå WRONG - Spaghetti Logging
```typescript
console.log('here');
console.log('data:', data);
console.log('test');
```

### ‚úÖ CORRECT - Structured Logging
```typescript
console.log('[ComponentName] üöÄ Event:', {
  timestamp: new Date().toISOString(),
  userId: user.id,
  action: 'FETCH_DATA',
  params: { page, limit },
});

console.log('[ComponentName] ‚úÖ Success:', {
  duration: Date.now() - startTime,
  resultCount: data.length,
});

console.error('[ComponentName] ‚ùå Error:', {
  error: error.message,
  stack: error.stack,
  context: { userId, action },
});
```

### Log Levels
- `üöÄ` - Function entry / Start
- `‚úÖ` - Success / Completion
- `‚ùå` - Error
- `‚ö†Ô∏è` - Warning
- `üìä` - Data snapshot
- `üîÑ` - State change
- `üêõ` - Debug info

---

## Backend Debugging

### 1. Request/Response Logging
```typescript
// middleware/logger.ts
app.use((req, res, next) => {
  const start = Date.now();
  
  res.on('finish', () => {
    logger.info('Request', {
      method: req.method,
      path: req.path,
      status: res.statusCode,
      duration: `${Date.now() - start}ms`,
      userId: req.user?.id,
    });
  });
  
  next();
});
```

### 2. Database Query Logging
```typescript
prisma.$on('query', (e) => {
  if (e.duration > 100) {
    logger.warn('Slow query', {
      query: e.query.substring(0, 200),
      duration: `${e.duration}ms`,
      params: e.params,
    });
  }
});
```

### 3. Error Context
```typescript
try {
  await updateItem(itemId, data);
} catch (error) {
  logger.error('Failed to update item', {
    error: error instanceof Error ? error.message : 'Unknown',
    itemId,
    data,
    stack: error instanceof Error ? error.stack : undefined,
  });
  throw error;
}
```

---

## Frontend Debugging

### 1. React Query DevTools
```typescript
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';

<QueryClientProvider client={queryClient}>
  <App />
  <ReactQueryDevtools initialIsOpen={false} />
</QueryClientProvider>
```

**Features:**
- Query status (fresh, stale, fetching)
- Cache inspection
- Manual refetch
- Query invalidation

### 2. Component State Tracking
```typescript
useEffect(() => {
  console.log('[MyComponent] üîÑ State changed:', {
    timestamp: Date.now(),
    state: {
      items: items.length,
      loading: isLoading,
      error: error?.message,
    },
  });
}, [items, isLoading, error]);
```

### 3. Props Debugging
```typescript
function MyComponent(props: MyProps) {
  useEffect(() => {
    console.log('[MyComponent] üìä Props:', props);
  }, [props]);
  
  // ... rest of component
}
```

---

## Network Debugging

### 1. Fetch with Timing
```typescript
async function fetchWithTiming(url: string) {
  const start = performance.now();
  
  try {
    const response = await fetch(url);
    const data = await response.json();
    
    console.log('[API] ‚úÖ Success:', {
      url,
      duration: `${(performance.now() - start).toFixed(2)}ms`,
      status: response.status,
      dataSize: JSON.stringify(data).length,
    });
    
    return data;
  } catch (error) {
    console.error('[API] ‚ùå Error:', {
      url,
      duration: `${(performance.now() - start).toFixed(2)}ms`,
      error: error instanceof Error ? error.message : 'Unknown',
    });
    throw error;
  }
}
```

### 2. Browser DevTools Network Tab
- **Size:** Check response size (large JSON?)
- **Time:** TTFB vs Download time
- **Status:** 200 OK vs errors
- **Preview:** Verify response structure

---

## Race Condition Debugging

### Detecting Race Conditions
```typescript
let requestId = 0;

async function fetchData(params: Params) {
  const currentRequestId = ++requestId;
  console.log('[fetchData] üöÄ Starting request:', currentRequestId);
  
  const result = await api.fetch(params);
  
  if (currentRequestId !== requestId) {
    console.log('[fetchData] ‚ö†Ô∏è Outdated request, ignoring:', currentRequestId);
    return; // Newer request already started
  }
  
  console.log('[fetchData] ‚úÖ Using result from request:', currentRequestId);
  setData(result);
}
```

### useEffect Race Condition
```typescript
useEffect(() => {
  let cancelled = false;
  
  async function fetchData() {
    const result = await api.fetch();
    
    if (!cancelled) {
      setData(result);
    } else {
      console.log('[useEffect] ‚ö†Ô∏è Effect cancelled, ignoring result');
    }
  }
  
  fetchData();
  
  return () => {
    cancelled = true;
  };
}, []);
```

---

## Type Error Debugging

### TypeScript LSP Cache Issues

**Problem:** After Prisma schema change, TypeScript shows errors but code runs fine.

```
Property 'weekNumber' does not exist on type '{ id: string; name: string; ... }'
```

**Root Cause:** TypeScript Language Server cached old types.

**Solution:**
1. `Ctrl+Shift+P` ‚Üí "TypeScript: Restart TS Server"
2. Or restart IDE
3. Verify Prisma client regenerated: `npx prisma generate`

### Narrowing `unknown` Types
```typescript
// ‚ùå WRONG
const data = apiResponse as MyType;

// ‚úÖ CORRECT - Runtime validation
import { z } from 'zod';

const MySchema = z.object({
  id: z.string(),
  name: z.string(),
});

const data = MySchema.parse(apiResponse);  // Throws if invalid
```

---

## Performance Debugging

### 1. React DevTools Profiler
- Record interaction
- Identify slow renders
- Check re-render causes

### 2. Performance API
```typescript
const start = performance.now();

// ... expensive operation

const duration = performance.now() - start;
if (duration > 100) {
  console.warn('[Performance] ‚ö†Ô∏è Slow operation:', {
    operation: 'calculateOptimization',
    duration: `${duration.toFixed(2)}ms`,
  });
}
```

### 3. Render Count Tracking
```typescript
const renderCount = useRef(0);

useEffect(() => {
  renderCount.current += 1;
  console.log('[MyComponent] üîÑ Render #', renderCount.current);
});
```

---

## Debug Checklist

### Before Adding More Logs
- [ ] Consulted browser DevTools Network tab?
- [ ] Checked React Query DevTools?
- [ ] Verified backend returns correct data?
- [ ] Checked for race conditions?
- [ ] Reviewed recent code changes?
- [ ] TypeScript errors vs runtime errors?
- [ ] Tested in isolation (minimal reproduction)?

### When Stuck
- [ ] Take a break (fresh eyes)
- [ ] Explain problem out loud (rubber duck)
- [ ] Binary search (disable half the code)
- [ ] Check assumptions (is API really returning what you think?)
- [ ] Search similar issues (GitHub, Stack Overflow)

---

## Anti-Patterns

### ‚ùå Commenting Out Code
```typescript
// setData(result);  // ‚ùå Why is this commented?
```
**Better:** Remove or document why.

### ‚ùå Production Console Logs
```typescript
console.log('test');  // ‚ùå Remove before commit
```
**Better:** Use logger with log levels, strip in production.

### ‚ùå Catching and Ignoring Errors
```typescript
try {
  await riskyOperation();
} catch {
  // ‚ùå Silent failure
}
```
**Better:** Log error with context, handle gracefully.

### ‚ùå Multiple Fixes at Once
```typescript
// Changed 5 things at once, which one fixed it? ü§∑
```
**Better:** One fix at a time, test, commit.

---

## Root Cause Analysis Template

```markdown
## Problem
[Describe the issue]

## Symptoms
- [What user sees]
- [When it happens]
- [Frequency]

## Initial Hypotheses
1. [Hypothesis 1] ‚Üí [Test result]
2. [Hypothesis 2] ‚Üí [Test result]

## Root Cause
[The actual underlying cause]

## Fix Applied
[Code changes made]

## Verification
- [ ] Manual testing
- [ ] Added logging
- [ ] Added test case
- [ ] Documented

## Prevention
[How to avoid this in the future]
```

---

## References

- [Logger Service](mdc:backend/src/services/logger.ts)
- [Error Handler Middleware](mdc:backend/src/middleware/errorHandler.ts)
- [React Query Configuration](mdc:frontend/src/App/providers/QueryProvider.tsx)
