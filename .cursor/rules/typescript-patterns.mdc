---
alwaysApply: true
globs: *.ts,*.tsx
---

# TypeScript Patterns for Lemnix

## Strict Type Safety Rules

### ❌ NEVER USE
- `any` type
- Non-null assertion (`!`) without justification
- `@ts-ignore` or `@ts-expect-error`
- Implicit `any` in function parameters

### ✅ ALWAYS USE
- `unknown` instead of `any`, then narrow with type guards
- `readonly` for immutable data
- `as const` for literal types
- Explicit return types for public functions
- Discriminated unions for state management

## Type Narrowing Patterns

### Type Guards
```typescript
// ✅ Good
function isError(value: unknown): value is Error {
  return value instanceof Error;
}

// Usage
if (isError(error)) {
  console.error(error.message); // TypeScript knows it's Error
}
```

### Unknown Narrowing
```typescript
// ✅ Good
try {
  // ...
} catch (error: unknown) {
  const err = error as { response?: { status?: number } };
  if (err.response?.status === 401) {
    // Handle 401
  } else {
    console.warn('Error:', error);
  }
}
```

## Readonly & Immutability

### Props Interfaces
```typescript
// ✅ Good - All readonly
export interface ButtonProps {
  readonly variant: 'primary' | 'secondary';
  readonly onClick: () => void;
  readonly disabled?: boolean;
  readonly children: React.ReactNode;
}
```

### Arrays and Objects
```typescript
// ✅ Good - ReadonlyArray
function processItems(items: ReadonlyArray<Item>): ReadonlyArray<Result> {
  return items.map(item => transform(item));
}

// ✅ Good - Readonly object
interface Config {
  readonly apiUrl: string;
  readonly timeout: number;
}
```

## Discriminated Unions

### State Management
```typescript
// ✅ Good - Discriminated union
type AsyncState<T> =
  | { status: 'idle' }
  | { status: 'loading' }
  | { status: 'success'; data: T }
  | { status: 'error'; error: Error };

function renderData<T>(state: AsyncState<T>) {
  switch (state.status) {
    case 'idle':
      return <div>Ready to load</div>;
    case 'loading':
      return <Spinner />;
    case 'success':
      return <div>{state.data}</div>; // TypeScript knows data exists
    case 'error':
      return <Error error={state.error} />; // TypeScript knows error exists
  }
}
```

### Result Pattern
```typescript
type Result<T, E = Error> =
  | { success: true; data: T }
  | { success: false; error: E };

function parseJson<T>(json: string): Result<T> {
  try {
    const data = JSON.parse(json);
    return { success: true, data };
  } catch (error) {
    return { 
      success: false, 
      error: error instanceof Error ? error : new Error('Parse failed')
    };
  }
}

// Usage
const result = parseJson<User>('{"name":"John"}');
if (result.success) {
  console.log(result.data.name); // Type-safe
} else {
  console.error(result.error.message);
}
```

## Generic Constraints

```typescript
// ✅ Good - Constrained generics
interface Entity {
  id: string;
}

function findById<T extends Entity>(items: ReadonlyArray<T>, id: string): T | undefined {
  return items.find(item => item.id === id);
}
```

## Literal Types & as const

```typescript
// ✅ Good - Literal types
const ALGORITHMS = ['ffd', 'bfd', 'genetic', 'pooling'] as const;
type AlgorithmType = typeof ALGORITHMS[number]; // 'ffd' | 'bfd' | 'genetic' | 'pooling'

// ✅ Good - as const for objects
const HTTP_STATUS = {
  OK: 200,
  UNAUTHORIZED: 401,
  NOT_FOUND: 404,
} as const;
```

## Optional Chaining & Nullish Coalescing

```typescript
// ✅ Good - Safe property access
const userName = user?.profile?.name ?? 'Unknown';

// ✅ Good - Safe array access
const firstItem = items?.[0];

// ✅ Good - Safe function call
const result = callback?.();
```

## Type Assertions (Use Sparingly)

```typescript
// ❌ Bad - Unsafe assertion
const user = data as User;

// ✅ Good - With validation
import { z } from 'zod';

const UserSchema = z.object({
  id: z.string(),
  name: z.string(),
});

const user = UserSchema.parse(data); // Runtime + compile-time safety
```

## Function Signatures

```typescript
// ✅ Good - Explicit return type
export function calculateTotal(items: ReadonlyArray<Item>): number {
  return items.reduce((sum, item) => sum + item.price, 0);
}

// ✅ Good - Async explicit return
export async function fetchUser(id: string): Promise<User> {
  const response = await api.get(`/users/${id}`);
  return UserSchema.parse(response.data);
}

// ✅ Good - Object parameter for many params
interface CreateUserParams {
  readonly name: string;
  readonly email: string;
  readonly age: number;
  readonly role: string;
}

export function createUser(params: CreateUserParams): User {
  // ...
}
```

## React Component Types

```typescript
// ✅ Good - Functional component with props
export const Button: React.FC<ButtonProps> = ({
  variant,
  onClick,
  disabled = false,
  children
}) => {
  return (
    <button onClick={onClick} disabled={disabled}>
      {children}
    </button>
  );
};

// ✅ Good - Generic component
interface ListProps<T> {
  readonly items: ReadonlyArray<T>;
  readonly renderItem: (item: T) => React.ReactNode;
  readonly keyExtractor: (item: T) => string;
}

export function List<T>({ items, renderItem, keyExtractor }: ListProps<T>) {
  return (
    <ul>
      {items.map(item => (
        <li key={keyExtractor(item)}>
          {renderItem(item)}
        </li>
      ))}
    </ul>
  );
}
```

## Utility Types

```typescript
// ✅ Good - Extract type from array
const COLORS = ['red', 'blue', 'green'] as const;
type Color = typeof COLORS[number];

// ✅ Good - Pick specific props
type UserPreview = Pick<User, 'id' | 'name' | 'avatar'>;

// ✅ Good - Make all optional
type PartialUser = Partial<User>;

// ✅ Good - Make all required
type RequiredUser = Required<User>;

// ✅ Good - Extract function parameters
type CreateUserParams = Parameters<typeof createUser>[0];

// ✅ Good - Extract function return type
type UserResult = ReturnType<typeof createUser>;
```

## Lemnix-Specific Patterns

### Optimization Item
```typescript
export interface OptimizationItem {
  readonly id?: string;
  readonly profileType: string;
  readonly length: number;
  readonly quantity: number;
  readonly totalLength: number;
  readonly workOrderId?: string;
  readonly color?: string;
  readonly version?: string;
  readonly size?: string;
}
```

### Algorithm Catalog
```typescript
export const ALGORITHM_CATALOG: Record<AlgorithmType, AlgorithmInfo> = {
  ffd: { /* ... */ },
  bfd: { /* ... */ },
  genetic: { /* ... */ },
  pooling: { /* ... */ },
} as const;

export type AlgorithmType = keyof typeof ALGORITHM_CATALOG;
```

### React Query Hook Pattern
```typescript
export function useOptimizationResult(id: string) {
  return useQuery({
    queryKey: ['optimization', 'result', id] as const,
    queryFn: () => getOptimizationResult(id),
    enabled: !!id,
    staleTime: 5 * 60 * 1000,
    retry: (failureCount, error) => {
      if ((error as any)?.response?.status === 401) {
        return false;
      }
      return failureCount < 3;
    },
  });
}
```

## Common Mistakes to Avoid

### ❌ Implicit any in array methods
```typescript
// ❌ Bad
items.map(item => item.name); // item is any

// ✅ Good
items.map((item: Item) => item.name);
// Or better with typed array
const items: ReadonlyArray<Item> = [...];
items.map(item => item.name); // item is Item
```

### ❌ Optional property access without checking
```typescript
// ❌ Bad
const name = user.profile.name; // Runtime error if profile is undefined

// ✅ Good
const name = user.profile?.name;
// Or with default
const name = user.profile?.name ?? 'Unknown';
```

### ❌ Index access without checking
```typescript
// ❌ Bad (with noUncheckedIndexedAccess)
const first = array[0]; // Type: Item | undefined

// ✅ Good - Handle undefined
const first = array[0];
if (first) {
  console.log(first.name); // Type: Item
}

// Or with nullish coalescing
const first = array[0] ?? getDefaultItem();
```

## File References

- [TypeScript Config](mdc:frontend/tsconfig.json)
- [Backend TypeScript Config](mdc:backend/tsconfig.json)
- [Optimization Types](mdc:frontend/src/entities/optimization/model/types.ts)
