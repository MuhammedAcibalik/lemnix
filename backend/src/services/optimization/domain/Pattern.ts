/**
 * LEMNÄ°X Pattern Domain Types
 * Pattern representation for exact search algorithms
 *
 * @module optimization/domain
 * @version 1.0.0
 *
 * IMPORTANT: This is NOT classical column generation (RMP + pricing problem).
 * This is pattern enumeration + exact search with lexicographic optimization.
 */

/**
 * Cutting pattern for a single stock length
 * Represents how one stock bar can be cut into demand items
 */
export interface Pattern {
  /**
   * Unique identifier for this pattern
   * CRITICAL: Used as Map key instead of object reference
   * to avoid equality/serialization issues
   */
  readonly id: string;

  /** Stock length this pattern uses */
  readonly stockLength: number;

  /** Items cut from this stock: length -> count */
  readonly items: ReadonlyMap<number, number>;

  /** Waste generated by this pattern (mm) */
  readonly waste: number;

  /** Utilization ratio (0-1): used length / stock length */
  readonly utilization: number;
}

/**
 * Solution returned by pattern solver
 * Represents which patterns to use and how many times
 */
export interface PatternSolution {
  /**
   * Pattern usage counts
   * Array of {patternId, count} pairs
   */
  readonly patternCounts: ReadonlyArray<{
    readonly patternId: string;
    readonly count: number;
  }>;

  /**
   * All patterns (for lookup by id)
   * Patterns are referenced by ID in patternCounts
   */
  readonly allPatterns: ReadonlyArray<Pattern>;

  /** Total number of stock bars used */
  readonly totalStocks: number;

  /** Total waste across all patterns (mm) */
  readonly totalWaste: number;
}

/**
 * Helper to create pattern ID deterministically
 */
export function createPatternId(
  stockLength: number,
  items: ReadonlyMap<number, number>,
): string {
  // Sort item lengths for deterministic ID
  const sortedLengths = Array.from(items.keys()).sort((a, b) => a - b);
  const itemsStr = sortedLengths
    .map((length) => `${length}x${items.get(length)}`)
    .join("_");
  return `${stockLength}_${itemsStr}`;
}

/**
 * Calculate utilization ratio
 */
export function calculateUtilization(
  stockLength: number,
  items: ReadonlyMap<number, number>,
): number {
  let usedLength = 0;
  for (const [length, count] of items) {
    usedLength += length * count;
  }
  return stockLength > 0 ? usedLength / stockLength : 0;
}

/**
 * Check if a pattern is empty (no items)
 */
export function isEmptyPattern(pattern: Pattern): boolean {
  return pattern.items.size === 0;
}

/**
 * Check if pattern A dominates pattern B
 * A dominates B if:
 * - Same stock length
 * - Same items (or A has more of every item)
 * - A has less or equal waste
 */
export function dominates(patternA: Pattern, patternB: Pattern): boolean {
  // Must be same stock length
  if (patternA.stockLength !== patternB.stockLength) {
    return false;
  }

  // A must have less or equal waste
  if (patternA.waste > patternB.waste) {
    return false;
  }

  // Get all unique item lengths
  const allLengths = new Set([
    ...patternA.items.keys(),
    ...patternB.items.keys(),
  ]);

  // Check if A has at least as many of every item
  for (const length of allLengths) {
    const countA = patternA.items.get(length) || 0;
    const countB = patternB.items.get(length) || 0;

    if (countA < countB) {
      return false;
    }
  }

  // A is at least as good in all aspects, better in at least one
  return (
    patternA.waste < patternB.waste ||
    Array.from(allLengths).some((length) => {
      const countA = patternA.items.get(length) || 0;
      const countB = patternB.items.get(length) || 0;
      return countA > countB;
    })
  );
}
