/**
 * @fileoverview CuttingListBuilder - Enterprise UX Edition
 * @module CuttingListBuilder
 * @version 8.0.0 - Final UX Polish
 */

import React, { useEffect, useState, useCallback } from "react";
import { Container, Alert, Snackbar } from "@mui/material";

import { useDesignSystem } from "@/shared/hooks";
import { useApplySmartSuggestion } from "@/entities/suggestions";

import {
  CuttingList,
  LoadingState,
  WorkOrderItem,
  ProfileCombination,
} from "./types";

import { useCuttingListState } from "./hooks/useCuttingListState";
import { useCuttingListData } from "./hooks/useCuttingListData";
import { useSmartSuggestions } from "./hooks/useSmartSuggestions";

import { MainTab } from "./tabs/MainTab";

import { NewProductDialog } from "./dialogs/NewProductDialog";
import { NewItemDialog } from "./dialogs/NewItemDialog";
import { EditItemDialog } from "./dialogs/EditItemDialog";
import { CombinationDialog } from "./dialogs/CombinationDialog";

export const CuttingListBuilder: React.FC = () => {
  const ds = useDesignSystem();
  const { applyAsync } = useApplySmartSuggestion();

  // Local state management
  const {
    cuttingList,
    cuttingLists,
    title,
    selectedWeekNumber,
    productName,
    loadingState,
    error,
    success,
    showNewProductDialog,
    showNewItemDialog,
    showEditItemDialog,
    showCombinationDialog,
    currentSectionId,
    editingItem,
    expandedSections,
    newItemForm,
    availableSizes,
    profileCombinations,
    isLoadingSuggestions,
    currentWeekNumber,
    autoGeneratedTitle,
    cuttingListStats,
    isFormValid,
    resetNewItemForm,
    handleFormChange,
    addProfile,
    removeProfile,
    convertMeasurementToMM,
    handleProfileChange,
    handleEditItem,
    toggleSectionExpansion,
    copyItemToClipboard,
    setCuttingList,
    setCuttingLists,
    setTitle,
    setSelectedWeekNumber,
    setProductName,
    setLoadingState,
    setError,
    setSuccess,
    setShowNewProductDialog,
    setShowNewItemDialog,
    setShowEditItemDialog,
    setShowCombinationDialog,
    setCurrentSectionId,
    setEditingItem,
    setExpandedSections,
    setNewItemForm,
    setAvailableSizes,
    setProfileCombinations,
    setIsLoadingSuggestions,
  } = useCuttingListState();

  // Smart suggestion handler
  const handleApplySmartSuggestion = useCallback(async () => {
    if (
      !newItemForm.productName ||
      !newItemForm.size ||
      !newItemForm.orderQuantity
    ) {
      setError("ÃœrÃ¼n adÄ±, ebat ve sipariÅŸ adedi gerekli");
      return;
    }

    try {
      setLoadingState(LoadingState.LOADING);

      console.log("ðŸ” Smart Suggestion Request:", {
        productName: newItemForm.productName,
        size: newItemForm.size,
        orderQuantity: newItemForm.orderQuantity,
        contextKey: `${newItemForm.productName?.toUpperCase().trim()}|${newItemForm.size?.toUpperCase().trim()}`,
      });

      const result = await applyAsync(
        newItemForm.productName,
        newItemForm.size,
        parseInt(newItemForm.orderQuantity, 10),
      );

      console.log("ðŸ“Š Smart Suggestion Response:", {
        profileCount: result.profiles.length,
        totalConfidence: result.totalConfidence,
        profiles: result.profiles,
      });

      if (result.profiles.length > 0) {
        // âœ… FIXED: Direct state update - no ID mismatch
        const suggestedProfiles = result.profiles.map((p, index) => ({
          id: `profile-${Date.now()}-${index}`,
          profile: p.profile,
          measurement: p.measurement,
          quantity: p.quantity.toString(),
        }));

        // Replace all profiles with suggestions (atomic update)
        setNewItemForm((prev) => ({
          ...prev,
          profiles: suggestedProfiles,
        }));

        setSuccess(
          `âœ¨ ${result.profiles.length} profil akÄ±llÄ± Ã¶neri ile eklendi! (GÃ¼ven: %${result.totalConfidence})`,
        );
      } else {
        setError("Bu Ã¼rÃ¼n ve ebat iÃ§in akÄ±llÄ± Ã¶neri bulunamadÄ±");
      }
    } catch (error) {
      console.error("Smart suggestion failed:", error);
      setError("AkÄ±llÄ± Ã¶neri alÄ±nÄ±rken hata oluÅŸtu");
    } finally {
      setLoadingState(LoadingState.IDLE);
    }
  }, [
    newItemForm,
    applyAsync,
    setLoadingState,
    setNewItemForm,
    setError,
    setSuccess,
  ]);

  // âœ… DIRECT FETCH: Single state update, no intermediate layer
  const fetchCuttingLists = useCallback(async () => {
    console.log("[CuttingListBuilder] ðŸš€ Fetching cutting lists...");
    setLoadingState(LoadingState.LOADING);
    setError(null);

    try {
      const response = await fetch("/api/cutting-list", {
        cache: "no-cache", // Disable cache to always get fresh data
        headers: {
          "Cache-Control": "no-cache",
          Pragma: "no-cache",
        },
      });
      if (!response.ok) {
        const text = await response.text().catch(() => "");
        throw new Error(text || `Sunucu hatasÄ± (${response.status})`);
      }
      const result = await response.json();

      if (result.success && result.data) {
        console.log(
          "[CuttingListBuilder] âœ… Loaded:",
          result.data.length,
          "lists",
        );
        // DIRECT UPDATE - No intermediate state
        setCuttingLists(result.data);
        setLoadingState(LoadingState.SUCCESS);
      } else {
        console.warn("[CuttingListBuilder] âŒ API returned no data");
        setCuttingLists([]);
        setLoadingState(LoadingState.ERROR);
        setError("Kesim listeleri yÃ¼klenemedi");
      }
    } catch (error) {
      console.error("[CuttingListBuilder] API error:", error);
      setCuttingLists([]);
      setLoadingState(LoadingState.ERROR);
      setError(error instanceof Error ? error.message : "Beklenmeyen hata");
    }
  }, []); // âœ… Empty deps - setState functions are stable in React

  // âœ… FETCH ON MOUNT: Direct call, no cache
  useEffect(() => {
    fetchCuttingLists();
  }, [fetchCuttingLists]);

  // âœ… AUTO-DISMISS: Error messages auto-clear after 6 seconds
  useEffect(() => {
    if (error) {
      const timer = setTimeout(() => {
        setError(null);
      }, 6000); // 6 seconds

      return () => clearTimeout(timer);
    }
    return undefined;
  }, [error, setError]);

  // âœ… AUTO-DISMISS: Success messages auto-clear after 4 seconds
  useEffect(() => {
    if (success) {
      const timer = setTimeout(() => {
        setSuccess(null);
      }, 4000); // 4 seconds

      return () => clearTimeout(timer);
    }
    return undefined;
  }, [success, setSuccess]);

  const {
    createCuttingList,
    addProductSection,
    addItemToSection,
    updateItemInSection,
    updateSection,
    deleteItem,
    deleteSection,
    exportToPDF,
    exportToExcel,
    handleError,
  } = useCuttingListData({
    cuttingList,
    setCuttingList,
    setCuttingLists,
    cuttingLists,
    title,
    selectedWeekNumber,
    productName,
    currentSectionId,
    newItemForm,
    editingItem,
    isFormValid,
    setLoadingState,
    setError,
    setSuccess,
    setShowNewProductDialog,
    setShowNewItemDialog,
    setShowEditItemDialog,
    setEditingItem,
    resetNewItemForm,
  });

  const { getAvailableSizes, getProfileCombinations, applyProfileCombination } =
    useSmartSuggestions({
      setAvailableSizes,
      setProfileCombinations,
      setIsLoadingSuggestions,
      setNewItemForm,
      setShowCombinationDialog,
      setSuccess,
    });

  // âœ… REMOVED: Old useEffect with loadCuttingListsFromBackend
  // React Query automatically fetches on mount

  const handleAddProduct = () => setShowNewProductDialog(true);
  const handleAddItem = (sectionId: string) => {
    setCurrentSectionId(sectionId);

    // âœ… CRITICAL FIX: Populate productName from section for smart suggestions
    const section = cuttingList?.sections.find((s) => s.id === sectionId);
    if (section) {
      setNewItemForm((prev) => ({
        ...prev,
        productName: section.productName,
      }));
    }

    setShowNewItemDialog(true);
  };
  const handleEditItemClick = (sectionId: string, item: WorkOrderItem) => {
    setCurrentSectionId(sectionId);
    handleEditItem(sectionId, item);
  };
  const handleDeleteItem = (sectionId: string, itemId: string) =>
    deleteItem(sectionId, itemId);
  const handleDeleteSection = (sectionId: string) => deleteSection(sectionId);
  const handleCopyItem = (item: WorkOrderItem) => copyItemToClipboard(item);
  const handleBackToList = () => setCuttingList(null);
  const handleApplyCombination = (
    combination: ProfileCombination,
    orderQuantity: number,
  ) => {
    applyProfileCombination(combination, orderQuantity);
  };

  // Handle delete list from local state
  const handleDeleteList = (id: string) => {
    console.log("ðŸ—‘ï¸ Deleting list from local state:", id);
    setCuttingLists((prevLists) => prevLists.filter((list) => list.id !== id));

    // If the deleted list was selected, clear selection
    if (cuttingList?.id === id) {
      setCuttingList(null);
    }
  };

  const renderMainContent = () => {
    return (
      <MainTab
        cuttingList={cuttingList}
        cuttingLists={cuttingLists}
        currentWeekNumber={currentWeekNumber}
        title={title}
        selectedWeekNumber={selectedWeekNumber}
        loadingState={loadingState}
        onTitleChange={setTitle}
        onWeekNumberChange={setSelectedWeekNumber}
        onCreateList={createCuttingList}
        onSelectList={setCuttingList}
        onDeleteList={handleDeleteList}
        onAddProduct={handleAddProduct}
        onExportPDF={exportToPDF}
        onExportExcel={exportToExcel}
        onBackToList={handleBackToList}
        onAddItem={handleAddItem}
        onDeleteSection={handleDeleteSection}
        onEditItem={handleEditItemClick}
        onDeleteItem={handleDeleteItem}
        onCopyItem={handleCopyItem}
      />
    );
  };

  return (
    <Container
      maxWidth="xl"
      sx={{
        py: ds.spacing["3"],
        px: ds.spacing["2"],
        // Add top padding to account for fixed header
        pt: `${64 + ds.spacing["3"]}px`, // 64px header height + spacing
        minHeight: "100vh",
      }}
    >
      {error && (
        <Alert
          severity="error"
          sx={{
            mb: ds.spacing["2"],
            borderRadius: `${ds.borderRadius.md}px`,
            fontSize: "0.8125rem",
            py: ds.spacing["1"],
          }}
          onClose={() => setError(null)}
        >
          {error}
        </Alert>
      )}

      {success && (
        <Alert
          severity="success"
          sx={{
            mb: ds.spacing["2"],
            borderRadius: `${ds.borderRadius.md}px`,
            fontSize: "0.8125rem",
            py: ds.spacing["1"],
          }}
          onClose={() => setSuccess(null)}
        >
          {success}
        </Alert>
      )}

      {renderMainContent()}

      <NewProductDialog
        open={showNewProductDialog}
        onClose={() => setShowNewProductDialog(false)}
        onAddProduct={async (productName: string) => {
          // âœ… CRITICAL FIX: Pass productName directly to avoid race condition
          // React state updates are async - can't rely on setProductName completing first
          setProductName(productName);
          await addProductSection(productName);
        }}
        isLoading={loadingState === LoadingState.LOADING}
      />

      <NewItemDialog
        open={showNewItemDialog}
        onClose={() => setShowNewItemDialog(false)}
        newItemForm={newItemForm}
        setNewItemForm={setNewItemForm}
        isFormValid={isFormValid}
        loadingState={{
          isLoading: loadingState === LoadingState.LOADING,
          error: error || null,
        }}
        availableSizes={availableSizes}
        isLoadingSuggestions={isLoadingSuggestions}
        profileCombinations={profileCombinations}
        onAddItem={addItemToSection}
        onAddProfile={addProfile}
        onRemoveProfile={removeProfile}
        onProfileChange={handleProfileChange}
        onFormChange={handleFormChange}
        onGetAvailableSizes={() => {
          const currentSection = cuttingList?.sections.find(
            (s) => s.id === currentSectionId,
          );
          if (currentSection) {
            getAvailableSizes(currentSection.productName);
          }
        }}
        onShowCombinationDialog={() => setShowCombinationDialog(true)}
        onResetForm={resetNewItemForm}
        onApplySmartSuggestion={handleApplySmartSuggestion}
      />

      <EditItemDialog
        open={showEditItemDialog}
        onClose={() => setShowEditItemDialog(false)}
        item={editingItem}
        setEditItem={setEditingItem}
        onSaveItem={(updatedItem) => {
          if (currentSectionId) {
            updateItemInSection();
          }
        }}
        loadingState={{
          isLoading: loadingState === LoadingState.LOADING,
          error: error || null,
        }}
        availableSizes={availableSizes}
        isLoadingSuggestions={isLoadingSuggestions}
        profileCombinations={profileCombinations}
        onAddProfile={(itemId) => {
          // Add profile to editingItem
          if (editingItem) {
            const newProfile = {
              id: `profile-${Date.now()}`,
              profile: "",
              measurement: "",
              quantity: 1,
            };
            setEditingItem({
              ...editingItem,
              profiles: [
                ...(Array.isArray(editingItem.profiles)
                  ? editingItem.profiles
                  : []),
                newProfile,
              ],
            });
          }
        }}
        onRemoveProfile={(itemId, profileId) => {
          // Remove profile from editingItem
          if (editingItem && Array.isArray(editingItem.profiles)) {
            setEditingItem({
              ...editingItem,
              profiles: editingItem.profiles.filter((p) => p.id !== profileId),
            });
          }
        }}
        onProfileChange={(itemId, profileId, field, value) => {
          // Update profile in editingItem (keep raw numeric value; no unit suffix while typing)
          if (editingItem && Array.isArray(editingItem.profiles)) {
            setEditingItem({
              ...editingItem,
              profiles: editingItem.profiles.map((p) =>
                p.id === profileId
                  ? {
                      ...p,
                      [field]: value,
                    }
                  : p,
              ),
            });
          }
        }}
        onItemChange={(itemId, field, value) => {
          // Update field in editingItem
          if (editingItem) {
            setEditingItem({
              ...editingItem,
              [field]: value,
            });
          }
        }}
      />

      <CombinationDialog
        open={showCombinationDialog}
        onClose={() => setShowCombinationDialog(false)}
        combinations={profileCombinations}
        onSelectCombination={(combination) =>
          handleApplyCombination(combination, 1)
        }
        isLoading={isLoadingSuggestions}
      />

      <Snackbar
        open={!!success}
        autoHideDuration={3000}
        onClose={() => setSuccess(null)}
        anchorOrigin={{ vertical: "bottom", horizontal: "right" }}
      >
        <Alert
          onClose={() => setSuccess(null)}
          severity="success"
          variant="filled"
          sx={{
            borderRadius: `${ds.borderRadius.md}px`,
            fontSize: "0.75rem",
            fontWeight: 600,
          }}
        >
          {success}
        </Alert>
      </Snackbar>
    </Container>
  );
};
